{
  "author": "",
  "category": "",
  "extensionNamespace": "",
  "fullName": "",
  "helpPath": "",
  "iconUrl": "",
  "name": "CPUExtension",
  "previewIconUrl": "",
  "shortDescription": "",
  "version": "",
  "description": [
    "Add at beginning of scene",
    "",
    "example calling the cpu",
    "",
    "const cpuInstance = runtimeGame.CPUDefinition.CreateCPU(32, runtimeGame.CPUDefinition.InstructionSets.BASIC.Instructions, [",
    "        \"--comment\",",
    "        \"SET #0 24\",",
    "        \"SET #2 5\",",
    "        \"SET #4 1 --comment\",",
    "        \"--comment\",",
    "        \"LBL 0\",",
    "        \"SET >2 #3\",",
    "        \"ADD >2 #4\",",
    "        \"SET #3 #4\",",
    "        \"SET #4 >2\",",
    "        \"ADD #2 1\",",
    "        \"SUB #0 1\",",
    "        \"JLZ #0 1\",",
    "        \"JMP 0\",",
    "        \"LBL 1\",",
    "    ]);",
    "    for (let i = 0; i < 2000; i++) {",
    "        if (cpuInstance.step().line === 13) {",
    "            break;",
    "        }",
    "    }",
    "    console.log(\"CPU-Fib-Test\", cpuInstance.memory.getAt(29) === 121393);"
  ],
  "tags": [],
  "authorIds": [],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "description": "Initialise the CPU",
      "fullName": "",
      "functionType": "Action",
      "name": "InitCPU",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const runtimeGame = runtimeScene.getGame();",
            "var ParameterType;",
            "(function (ParameterType) {",
            "    ParameterType[(ParameterType[\"CONSTANT\"] = 0)] = \"CONSTANT\";",
            "    ParameterType[(ParameterType[\"LOCATION\"] = 1)] = \"LOCATION\";",
            "    ParameterType[(ParameterType[\"INDIRECT\"] = 2)] = \"INDIRECT\";",
            "})(ParameterType || (ParameterType = {}));",
            "var ParameterConstraint;",
            "(function (ParameterConstraint) {",
            "    ParameterConstraint[(ParameterConstraint[\"CONSTANT\"] = 0)] = \"CONSTANT\";",
            "    ParameterConstraint[(ParameterConstraint[\"MEMORY\"] = 1)] = \"MEMORY\";",
            "    ParameterConstraint[(ParameterConstraint[\"BOTH\"] = 2)] = \"BOTH\";",
            "})(ParameterConstraint || (ParameterConstraint = {}));",
            "class Memory {",
            "    constructor(size = 32) {",
            "        this.data = new Array(size).fill(0);",
            "    }",
            "    isLocationValid(index) {",
            "        return index >= 0 && index < this.data.length;",
            "    }",
            "    parseNumber(value) {",
            "        return Math.trunc(value);",
            "    }",
            "    getAt(index) {",
            "        if (!this.isLocationValid(index)) {",
            "            return null;",
            "        }",
            "        return this.data[index];",
            "    }",
            "    setAt(index, value) {",
            "        if (!this.isLocationValid(index)) {",
            "            return false;",
            "        }",
            "        this.data[index] = this.parseNumber(value);",
            "        return true;",
            "    }",
            "    getAtIndirect(index) {",
            "        if (!this.isLocationValid(index)) {",
            "            return null;",
            "        }",
            "        const indirectIndex = this.data[index];",
            "        if (!this.isLocationValid(indirectIndex)) {",
            "            return null;",
            "        }",
            "        return this.data[indirectIndex];",
            "    }",
            "    setAtIndirect(index, value) {",
            "        if (!this.isLocationValid(index)) {",
            "            return false;",
            "        }",
            "        const indirectIndex = this.data[index];",
            "        if (!this.isLocationValid(indirectIndex)) {",
            "            return false;",
            "        }",
            "        this.data[indirectIndex] = this.parseNumber(value);",
            "        return true;",
            "    }",
            "    getAllMemory() {",
            "        return this.data;",
            "    }",
            "}",
            "",
            "var ParseResultComments;",
            "(function (ParseResultComments) {",
            "    ParseResultComments[(ParseResultComments[\"OK\"] = 0)] = \"OK\";",
            "    ParseResultComments[(ParseResultComments[\"ERROR\"] = 1)] = \"ERROR\";",
            "    ParseResultComments[(ParseResultComments[\"NO_CODE\"] = 2)] = \"NO_CODE\";",
            "    ParseResultComments[(ParseResultComments[\"INVALID_INSTRUCTION\"] = 3)] =",
            "        \"INVALID_INSTRUCTION\";",
            "    ParseResultComments[(ParseResultComments[\"INVALID_PARAMETERS\"] = 4)] =",
            "        \"INVALID_PARAMETERS\";",
            "    ParseResultComments[(ParseResultComments[\"INVALID_PARAMETER\"] = 5)] =",
            "        \"INVALID_PARAMETER\";",
            "})(ParseResultComments || (ParseResultComments = {}));",
            "var StepResultComments;",
            "(function (StepResultComments) {",
            "    StepResultComments[(StepResultComments[\"OK\"] = 0)] = \"OK\";",
            "    StepResultComments[(StepResultComments[\"ERROR\"] = 1)] = \"ERROR\";",
            "    StepResultComments[(StepResultComments[\"OUT_OF_CODE\"] = 2)] = \"OUT_OF_CODE\";",
            "    StepResultComments[(StepResultComments[\"NO_INSTRUCTION\"] = 3)] =",
            "        \"NO_INSTRUCTION\";",
            "})(StepResultComments || (StepResultComments = {}));",
            "",
            "class CPU {",
            "    constructor(size, definitions, code) {",
            "        this.pointer = 0;",
            "        this.instructions = [];",
            "        this.commenter = \"--\";",
            "        this.memory = new Memory(size);",
            "        this.definitions = definitions;",
            "        this.parse(code);",
            "    }",
            "    getParameterValue(parameter) {",
            "        switch (parameter.type) {",
            "            case ParameterType.CONSTANT:",
            "                return parameter.value;",
            "            case ParameterType.LOCATION:",
            "                return this.memory.getAt(parameter.value);",
            "            case ParameterType.INDIRECT:",
            "                return this.memory.getAtIndirect(parameter.value);",
            "            default:",
            "                return null;",
            "        }",
            "    }",
            "    setParameterValue(parameter, value) {",
            "        switch (parameter.type) {",
            "            case ParameterType.LOCATION:",
            "                return this.memory.setAt(parameter.value, value);",
            "            case ParameterType.INDIRECT:",
            "                return this.memory.setAtIndirect(parameter.value, value);",
            "            default:",
            "                return false;",
            "        }",
            "    }",
            "    step() {",
            "        if (this.pointer < 0 || this.pointer >= this.instructions.length) {",
            "            return {",
            "                success: false,",
            "                line: this.pointer,",
            "                comment: StepResultComments.OUT_OF_CODE,",
            "            };",
            "        }",
            "        const instruction = this.instructions[this.pointer];",
            "        const result = instruction.definition.action(this, instruction);",
            "        if (!result) {",
            "            return {",
            "                success: false,",
            "                line: this.pointer,",
            "                comment: StepResultComments.NO_INSTRUCTION,",
            "            };",
            "        }",
            "        this.pointer++;",
            "        return {",
            "            success: true,",
            "            line: this.pointer,",
            "            comment: StepResultComments.OK,",
            "        };",
            "    }",
            "    parse(code) {",
            "        this.instructions = [];",
            "        for (let lineIndex = 0; lineIndex < code.length; lineIndex++) {",
            "            const line = this.processComments(code[lineIndex]);",
            "            if (!line) {",
            "                continue;",
            "            }",
            "            const [operation, ...parameterParts] = this.getInstructionParts(line);",
            "            const definition = this.getDefinition(operation);",
            "            if (!definition) {",
            "                return {",
            "                    success: false,",
            "                    line: lineIndex,",
            "                    comment: ParseResultComments.INVALID_INSTRUCTION,",
            "                };",
            "            }",
            "            const parameterCount = definition.parameterConstraints.length;",
            "            if (parameterCount !== parameterParts.length) {",
            "                return {",
            "                    success: false,",
            "                    line: lineIndex,",
            "                    comment: ParseResultComments.INVALID_PARAMETERS,",
            "                };",
            "            }",
            "            const parameters = [];",
            "            for (let paramIndex = 0; paramIndex < parameterCount; paramIndex++) {",
            "                const parameter = this.getParameter(parameterParts[paramIndex]);",
            "                if (!parameter) {",
            "                    return {",
            "                        success: false,",
            "                        line: lineIndex,",
            "                        comment: ParseResultComments.INVALID_PARAMETER,",
            "                    };",
            "                }",
            "                if (",
            "                    !this.validateParameter(",
            "                        parameter,",
            "                        definition.parameterConstraints[paramIndex]",
            "                    )",
            "                ) {",
            "                    return {",
            "                        success: false,",
            "                        line: lineIndex,",
            "                        comment: ParseResultComments.INVALID_PARAMETER,",
            "                    };",
            "                }",
            "                parameters.push(parameter);",
            "            }",
            "            this.instructions.push({",
            "                definition,",
            "                parameters,",
            "            });",
            "        }",
            "        return this.instructions.length === 0",
            "            ? {",
            "                success: false,",
            "                line: this.instructions.length,",
            "                comment: ParseResultComments.NO_CODE,",
            "            }",
            "            : {",
            "                success: true,",
            "                line: this.instructions.length,",
            "                comment: ParseResultComments.OK,",
            "            };",
            "    }",
            "    getDefinition(operation) {",
            "        return this.definitions.find((v) => v.label === operation);",
            "    }",
            "    getInstructionParts(line) {",
            "        return line.split(\" \").filter((v) => v !== \"\");",
            "    }",
            "    processComments(line) {",
            "        const commentIndex = line.indexOf(this.commenter);",
            "        if (commentIndex !== -1) {",
            "            line = line.substring(0, commentIndex).trimEnd();",
            "        }",
            "        return line.trim();",
            "    }",
            "    getParameter(parameter) {",
            "        const location = parameter.startsWith(\"#\");",
            "        const indirect = parameter.startsWith(\">\");",
            "        parameter = parameter.replace(\"#\", \"\").replace(\">\", \"\");",
            "        if (!/^-?\\d+$/.test(parameter)) {",
            "            return null;",
            "        }",
            "        const value = Number.parseInt(parameter);",
            "        const parameterType = location",
            "            ? ParameterType.LOCATION",
            "            : indirect",
            "                ? ParameterType.INDIRECT",
            "                : ParameterType.CONSTANT;",
            "        return { type: parameterType, value };",
            "    }",
            "    validateParameter(parameter, constraint) {",
            "        switch (constraint) {",
            "            case ParameterConstraint.CONSTANT:",
            "                return parameter.type === ParameterType.CONSTANT;",
            "            case ParameterConstraint.MEMORY:",
            "                return parameter.type !== ParameterType.CONSTANT;",
            "            case ParameterConstraint.BOTH:",
            "                return true;",
            "            default:",
            "                return false;",
            "        }",
            "    }",
            "}",
            "",
            "",
            "",
            "const BASIC = {",
            "    LBL: {",
            "        label: \"LBL\",",
            "        parameterConstraints: [ParameterConstraint.CONSTANT],",
            "        action: () => true,",
            "    },",
            "    SET: {",
            "        label: \"SET\",",
            "        parameterConstraints: [ParameterConstraint.MEMORY, ParameterConstraint.BOTH],",
            "        action: (cpu, instruction) => {",
            "            const p2 = cpu.getParameterValue(instruction.parameters[1]);",
            "            if (p2 === null) return false;",
            "            return cpu.setParameterValue(instruction.parameters[0], p2);",
            "        },",
            "    },",
            "    ADD: {",
            "        label: \"ADD\",",
            "        parameterConstraints: [",
            "            ParameterConstraint.MEMORY,",
            "            ParameterConstraint.BOTH,",
            "        ],",
            "        action: (cpu, instruction) => {",
            "            const p1 = cpu.getParameterValue(instruction.parameters[0]);",
            "            const p2 = cpu.getParameterValue(instruction.parameters[1]);",
            "            if (p1 === null || p2 === null) return false;",
            "            return cpu.setParameterValue(instruction.parameters[0], p1 + p2);",
            "        },",
            "    },",
            "    SUB: {",
            "        label: \"SUB\",",
            "        parameterConstraints: [",
            "            ParameterConstraint.MEMORY,",
            "            ParameterConstraint.BOTH,",
            "        ],",
            "        action: (cpu, instruction) => {",
            "            const p1 = cpu.getParameterValue(instruction.parameters[0]);",
            "            const p2 = cpu.getParameterValue(instruction.parameters[1]);",
            "            if (p1 === null || p2 === null) return false;",
            "            return cpu.setParameterValue(instruction.parameters[0], p1 - p2);",
            "        },",
            "    },",
            "    JMP: {",
            "        label: \"JMP\",",
            "        parameterConstraints: [ParameterConstraint.BOTH],",
            "        action: (cpu, instruction) => {",
            "            const p1 = cpu.getParameterValue(instruction.parameters[0]);",
            "            if (p1 === null) return false;",
            "            const idx = cpu.instructions.findIndex(",
            "                (v) => v.definition.label === \"LBL\" && v.parameters[0].value === p1",
            "            );",
            "            if (idx == -1) return false;",
            "            cpu.pointer = idx;",
            "            return true;",
            "        },",
            "    },",
            "    JEZ: {",
            "        label: \"JEZ\",",
            "        parameterConstraints: [",
            "            ParameterConstraint.BOTH,",
            "            ParameterConstraint.CONSTANT,",
            "        ],",
            "        action: (cpu, instruction) => {",
            "            const p1 = cpu.getParameterValue(instruction.parameters[0]);",
            "            const p2 = cpu.getParameterValue(instruction.parameters[1]);",
            "            if (p1 === null || p2 === null) return false;",
            "            if (p1 === 0) {",
            "                const idx = cpu.instructions.findIndex(",
            "                    (v) => v.definition.label === \"LBL\" && v.parameters[0].value === p2",
            "                );",
            "                if (idx == -1) return false;",
            "                cpu.pointer = idx;",
            "            }",
            "            return true;",
            "        },",
            "    },",
            "    JLZ: {",
            "        label: \"JLZ\",",
            "        parameterConstraints: [",
            "            ParameterConstraint.BOTH,",
            "            ParameterConstraint.CONSTANT,",
            "        ],",
            "        action: (cpu, instruction) => {",
            "            const p1 = cpu.getParameterValue(instruction.parameters[0]);",
            "            const p2 = cpu.getParameterValue(instruction.parameters[1]);",
            "            if (p1 === null || p2 === null) return false;",
            "            if (p1 < 0) {",
            "                const idx = cpu.instructions.findIndex(",
            "                    (v) => v.definition.label === \"LBL\" && v.parameters[0].value === p2",
            "                );",
            "                if (idx == -1) return false;",
            "                cpu.pointer = idx;",
            "            }",
            "            return true;",
            "        },",
            "    },",
            "};",
            "const BasicInstructionSet = [",
            "    BASIC.LBL,",
            "    BASIC.ADD,",
            "    BASIC.SUB,",
            "    BASIC.SET,",
            "    BASIC.JMP,",
            "    BASIC.JEZ,",
            "    BASIC.JLZ,",
            "];",
            "",
            "const FLIPBIT = {",
            "    LBL: {",
            "        label: \"LBL\",",
            "        parameterConstraints: [ParameterConstraint.CONSTANT],",
            "        action: () => true,",
            "    },",
            "    FLIPBIT: {",
            "        label: \"FLIPBIT\",",
            "        parameterConstraints: [",
            "            ParameterConstraint.MEMORY,",
            "            ParameterConstraint.CONSTANT,",
            "        ],",
            "        action: (cpu, instruction) => {",
            "            const p1 = cpu.getParameterValue(instruction.parameters[0]);",
            "            const p2 = cpu.getParameterValue(instruction.parameters[1]);",
            "            if (p1 === null || p2 === null) return false;",
            "            const value = p1 == 1 ? 0 : 1;",
            "            cpu.setParameterValue(instruction.parameters[0], value);",
            "            const idx = cpu.instructions.findIndex(",
            "                (v) => v.definition.label === \"LBL\" && v.parameters[0].value === p2",
            "            );",
            "            if (idx == -1) return false;",
            "            cpu.pointer = idx;",
            "            return true;",
            "        },",
            "    },",
            "};",
            "const FlipbitInstructionSet = [FLIPBIT.LBL, FLIPBIT.FLIPBIT];",
            "",
            "const P1EQ = {",
            "    LBL: {",
            "        label: \"LBL\",",
            "        parameterConstraints: [ParameterConstraint.CONSTANT],",
            "        action: () => true,",
            "    },",
            "    P1EQ: {",
            "        label: \"P1EQ\",",
            "        parameterConstraints: [",
            "            ParameterConstraint.MEMORY,",
            "            ParameterConstraint.BOTH,",
            "            ParameterConstraint.CONSTANT,",
            "        ],",
            "        action: (cpu, instruction) => {",
            "            const p1 = cpu.getParameterValue(instruction.parameters[0]);",
            "            const p2 = cpu.getParameterValue(instruction.parameters[1]);",
            "            const p3 = cpu.getParameterValue(instruction.parameters[2]);",
            "            if (p1 === null || p2 === null || p3 === null) return false;",
            "            const value = p1 + 1;",
            "            cpu.setParameterValue(instruction.parameters[1], value);",
            "            if (value == p2) {",
            "                const idx = cpu.instructions.findIndex(",
            "                    (v) => v.definition.label === \"LBL\" && v.parameters[0].value === p3",
            "                );",
            "                if (idx == -1) return false;",
            "                cpu.pointer = idx;",
            "                return true;",
            "            }",
            "            return true;",
            "        },",
            "    },",
            "};",
            "const P1eqInstructionSet = [P1EQ.LBL, P1EQ.P1EQ];",
            "",
            "const SUBLEQ = {",
            "    LBL: {",
            "        label: \"LBL\",",
            "        parameterConstraints: [ParameterConstraint.CONSTANT],",
            "        action: () => true,",
            "    },",
            "    SUBLEQ: {",
            "        label: \"SUBLEQ\",",
            "        parameterConstraints: [",
            "            ParameterConstraint.MEMORY,",
            "            ParameterConstraint.BOTH,",
            "            ParameterConstraint.CONSTANT,",
            "        ],",
            "        action: (cpu, instruction) => {",
            "            const p1 = cpu.getParameterValue(instruction.parameters[0]);",
            "            const p2 = cpu.getParameterValue(instruction.parameters[1]);",
            "            const p3 = cpu.getParameterValue(instruction.parameters[2]);",
            "            if (p1 === null || p2 === null || p3 === null) return false;",
            "            const value = p1 - p2;",
            "            cpu.setParameterValue(instruction.parameters[0], value);",
            "            if (value <= 0) {",
            "                const idx = cpu.instructions.findIndex(",
            "                    (v) => v.definition.label === \"LBL\" && v.parameters[0].value === p3",
            "                );",
            "                if (idx == -1) return false;",
            "                cpu.pointer = idx;",
            "                return true;",
            "            }",
            "            return true;",
            "        },",
            "    },",
            "};",
            "const SubleqInstructionSet = [SUBLEQ.LBL, SUBLEQ.SUBLEQ];",
            "",
            "const CPUDefinition = {};",
            "CPUDefinition.ParameterConstraint = ParameterConstraint;",
            "CPUDefinition.ParameterType = ParameterType;",
            "CPUDefinition.ParseResultComments = ParseResultComments;",
            "CPUDefinition.Memory = Memory;",
            "CPUDefinition.CPU = CPU;",
            "CPUDefinition.CreateCPU = (size, definitions, code) => new CPU(size, definitions, code);",
            "CPUDefinition.InstructionSets = {",
            "    BASIC: { Reference: BASIC, Instructions: BasicInstructionSet },",
            "    FLIPBIT: { Reference: FLIPBIT, Instructions: FlipbitInstructionSet },",
            "    P1EQ: { Reference: P1EQ, Instructions: P1eqInstructionSet },",
            "    SUBLEQ: { Reference: SUBLEQ, Instructions: SubleqInstructionSet },",
            "};",
            "CPUDefinition.CPUInstances = [];",
            "CPUDefinition.CPUTest = () => {",
            "    const cpuInstance = runtimeGame.CPUDefinition.CreateCPU(32, runtimeGame.CPUDefinition.InstructionSets.BASIC.Instructions, [",
            "        \"--comment\",",
            "        \"SET #0 24\",",
            "        \"SET #2 5\",",
            "        \"SET #4 1 --comment\",",
            "        \"--comment\",",
            "        \"LBL 0\",",
            "        \"SET >2 #3\",",
            "        \"ADD >2 #4\",",
            "        \"SET #3 #4\",",
            "        \"SET #4 >2\",",
            "        \"ADD #2 1\",",
            "        \"SUB #0 1\",",
            "        \"JLZ #0 1\",",
            "        \"JMP 0\",",
            "        \"LBL 1\",",
            "    ]);",
            "    for (let i = 0; i < 2000; i++) {",
            "        if (cpuInstance.step().line === 13) {",
            "            break;",
            "        }",
            "    }",
            "    console.log(\"CPU-Fib-Test\", cpuInstance.memory.getAt(29) === 121393);",
            "    console.log(\"CPU Tested\");",
            "}",
            "runtimeGame.CPUDefinition = CPUDefinition;",
            "console.log(\"CPU LOADED\");",
            "runtimeGame.CPUDefinition.CPUTest();"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}